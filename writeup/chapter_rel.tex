 \chapter{Related Work}
During the course of the years, many researchers made efforts in the fight against malware on Android and it is important to contextualize where \emph{DevArtist} places itself among existing solutions. Therefore, this chapter presents previous work on instrumentation of Android applications and/or their patching, discusses how they improve the \emph{state-of-the-art} and how they relate to this work.

\section{PatchDroid}
The most prominent tool in existing literature about patching security vulnerabilities on Android is \emph{PatchDroid}\cite{patchdroid}. Due to the OS fragmentation, this tool focuses on delivering security patches to older Android Devices, which are not updated anymore by the manufacturer. Mulliner et al, provide an Android application which is able to download, from a trusted repository, patches and apply them trough a daemon. In particular, this daemon computes the check of which patch to apply to which processes and is able to patch both native code and Dalvik byte-code.
Native code is replaced by a secure version by Inline Hooking or by hooking the Global Offset Table, whilst Dalvik Code instead is patched by hooking common system calls, such as \texttt{epoll\_wait()}, and replaced with a secure native one through the Dalvik JNI bridge. Moreover, the main functionality of PatchDroid can be also achieved by our system, as discussed in chapter \ref{ch:futurework}.

\section{CHEX}
This static vetting tool, is capable of detecting component hijacking and data leakages within an application. To achieve this goal, the authors define a set of common policies for leakages and, after the tool creates it from the Dalvik byte-code, the complete data-flow graph is checked against those policies to detect leakages. The most clarifying example Lu et all\cite{chex} make to explain the capabilities of the system is when the location of the user is sent through the network. In the example, CHEX is able to recognize that the policy: \enquote{Sensible Source ends in public output} is not respected and prevents the leakage. The functionalities provided by CHEX are also provided in prototypical form by \emph{TaintArtist} (a module inside \emph{Artist} itself), as stated in \cite{artist}, which started as a taint analysis tool. Therefore, our system includes and benefits from this research.

\section{FlowDroid}
In \cite{flowdroid}, Arzt et al. present the first static analyzer tool aware of the Android App's life-cycle and UI widgets. In fact, the asynchronous paradigm adopted by Android apps had limited immensely static analyzer tools up to that point. Therefore, FlowDroid extends what CHEX already did and manages to detect even more leakages from callbacks triggered by the Android Framework. In addition, in this paper also \emph{DroidBench} is presented: a micro benchmarking suite for Android flow analysis. In particular, this is a collection of 39 hand-crafted applications specifically created to be analyzed by static and dynamic tools. In this regard, \emph{TaintArtist} has been tested against the \emph{DroidBench} suite, making also \emph{DevArtist} benefit from this benchmarks. However, FlowDroid, in its current state can only detect but not patch those security leakages.

\section{EPICC and SIFTA}
Both EPICC\cite{epicc} and SIFTA\cite{sifta}, are evolutions of the above mentioned FlowDroid and their aim is to detect leakages on a broader scale. The first is able to detect privacy leaks happening when Inter Components Communication (ICC) is involved between more apps. In fact, it can create a data flow graph (from the Dalvik byte-code), which includes leaks in public components (exported, in Android) such as Intent Filters, Services, Receivers and all the others. SIFTA pushes the state of the art further by using FlowDroid and EPICC on all the installed apps as its first phase, but then, it uses their resulting graphs to create an even greater graph which includes all those applications. Unfortunately, the current state of \emph{TaintArtist} does not allow taint tracking across apps but, it can be achieved if both apps are also instrumented.

% \section{Static Analysis}
% Most of the research int his field focuses in detecting whether an app is malicious. In fact, static analyzers for Android are the first line of defense against malicious apps, due to the fact that their execution can be started directly when the apk is uploaded into the Play Store to detect anomalies in their behavior and block their proliferation before they are even downloaded from final users. Therefore, at the beginning of the research, projects such as Dare\cite{dare} aimed to re-target DVM byte-code to the correspondent Java byte-code, allowing the usage of all already available Java static analysis tools, but for Android apps. Afterwards, systems like CHEX\cite{chex} and Apposcopy\cite{apposcopy} were developed to specifically target Android apps, focusing more on privacy leaks generated from single components (exported Services and Content Providers) or to detect exploits similar to the \emph{GoldDream}\cite{golddream} malware family. Moreover, their strategy was based on the Dalvik byte-code because they were released before  Android 4.4 (KitKat). Only later, FlowDroid\cite{flowdroid} brought also the DroidBench benchmark suite, consisting of a multitude of test cases to assess the soundness and precision of static taint tracking approaches, which became practically the standard suite to test static analysis techniques. In fact, these tests were then re-used by systems such as Amandroid\cite{amandroid} and Iccta\cite{iccta}, which pushed forward the \emph{state-of-the-art} by enabling Inter-Component Communication (ICC) static analysis and also \emph{Artist}\cite{artist} was benchmarked with the above mentioned suite. Recently, the whole research above was even further extended by SIFTA\cite{sifta} which combines Flowdroid and EPICC\cite{EPICC} in its first phase to analyze single apps and then , in its second phase, constructs an \emph{inter-apps} graph by combining their information. Once the graph is ready, SIFTA can perform static analysis and detect leakages.\newline\newline
% \emph{DevArtist} is inherently different to the already presented static analyzers, due to its focus on patching. As a matter of fact, \emph{DevArtist} can not detect any information leakage or families of malware, but it can detect and patch specific and exploitable vulnerabilities. For this reason, it's not advisable to use \emph{DevArtist} as a tool to enforce security standards on apps of the play store as soon as they are uploaded.

% \section{Dynamic Analysis}
% The goal of dynamic analysis on Android aims to defend end users when a malicious app is already installed in the system. The research began with DroidTrace\cite{droidtrace}, which re-used the already existing Linux solution called\texttt{ptrace} to hook into system calls and trace them, preventing unwanted leakages. Afterwards, TaintDroid \cite{taintdroid} became the most used project due to the fact that it wasn't limited to system-calls, but it instruments directly the Android DVM to track information leakages in apps. However, the limit of this system were showed later with ScrubDroid(or AntiTaintDroid) by Sarwar et al in \cite{antitaintdroid}, when they managed to leak sensible private data such as the IMEI and the Android ID over the network without letting TaintDroid know.\newline\newline
% \emph{DevArtist}, again, differentiate itself from the above method dynamic analyzers because it doesn't detect when a private information is leaked at runtime, but it leverage the information available during execution to avoid the usage of insecure method calls or tainted variables. Moreover, \emph{Artist} is the first dynamic system which uses ART instead of DVM, which is now not in use, thus making TaintDroid not functional anymore.

% \section{Information Flow Control}
% As already mentioned in Chapter \ref{ch:background}, one of the fundamentals on which IFC stands is the concept of Program Slicing, published in \cite{slicing} by Reps and Yang. This concepts allows to reduce the execution path only to the important parts, thus allowing speed improvements in the analysis of programs and the study of taint variables directly derives from it.\newline\newline 
% //TODO check with Oliver if this section is needed and in case expand it\newline\newline
% Of this particular field, \emph{DevArtist} relies heavily on the concepts of Backward and Forward Slice to perform its computations, but it does not improve the \emph{state-of-the-art} in any way.

% \section{Compiler-Based Instrumentation}
% Beside \emph{Artist} (hence DevArtist), LLVM was also a major platform for compiler-assisted instrumentation, which allowed writing extension of the compiler thanks to its LLVM-Pass technology\cite{llvmpass}. In fact, project such as LLCov \footnote{\url{https://github.com/choller/LLCov}}, which is used for better code testing coverage, or LDC \footnote{\url{https://wiki.dlang.org/LDC_LLVM_profiling_instrumentation}} for profiling. However, not many projects on LLVM focus on security, with the exception of: AFL/LLVM\footnote{\url{https://github.com/mirrorer/afl/tree/master/llvm_mode}}, which is an LLVM implementation of the AFL Fuzzer, and "pa.llvm"\footnote{\url{https://github.com/codelion/pa.llvm}}, which (in theory) is able to perform dynamic taint analysis. However, all the projects are available only on GitHub, with scarce documentation and no peer-reviewed paper to support them.\newline\newline

% \emph{DevArtist} manages to be easier to use than any other compiler-assisted instrumentation, due to the fact that: in one hand, it does not require the developer to re-compile the program manually but it allows to use its application to check for the vulnerabilities, and in the other hand, it can be used by the final user without knowing anything that stands behind it.