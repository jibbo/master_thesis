\section{Static Analysis}
Static analyzers for Android are the first line of defense against malicious apps. They could be executed directly when the apk is uploaded into the Play Store to detect anomalies in their behavior and block their proliferation before they are even downloaded from final users. Therefore, at the beginning of the research, projects such as Dare\cite{dare} aimed to re-target DVM byte-code to the correspondent Java byte-code, allowing the usage of all already available Java static analysis tools, but for Android apps. Afterwards, systems like CHEX\cite{chex} and Apposcopy\cite{apposcopy} were developed to specifically target Android apps. However, they focused more on privacy leaks generated from single components (exported Services and Content Providers) or to detect exploits similar to the \emph{GoldDream}\cite{golddream} malware family. Moreover, their strategy was based on the Dalvik byte-code because they were released before  Android 4.4 (KitKat). Only later, FlowDroid\cite{flowdroid} brought also the DroidBench benchmark suite, consisting of a multitude of test cases to assess the soundness and precision of static taint tracking approaches, which became practically the standard suite to test static analysis techniques. In fact, these tests were then re-used by systems such as Amandroid\cite{amandroid} and Iccta\cite{iccta}, which pushed forward the \emph{state-of-the-art} by enabling Inter-Component Communication (ICC) static analysis and also \emph{Artist}\cite{artist} was benchmarked with the above mentioned suite. Unfortunately, at this moment, \emph{DevArtist} can't be used to detect issues derived from ICC, but this can be easily achieved if all the apps involved are instrumented. Finally, the whole research above is even further extended by SIFTA\cite{sifta} which combines Flowdroid and EPICC\cite{EPICC} in its first phase to analyze single apps and then , in its second phase, constructs an \emph{inter-apps} graph by combining their information. Once the graph is ready, SIFTA can perform static analysis and detect leakages. 

\section{Dynamic Analysis}



\section{App Instrumentation}


\section{Compiler-Based Instrumentation}

In the past, compiler extensions have been used to instrument programs during the compilation. Ashcraft and Engler propose a framework to use developer- written compiler extensions to find security vulnerabilities in code bases [38]. A similar work uses domain-knowledge provided in the form of state machines for such compiler extensions [39]. An instrumented GCC has also been used to insert code during the analysis of the Linux Security Framework [40], which was later used for verification purposes. Also, a recent USENIX Security paper [41] instruments a compiler to insert custom code at developer-marked posi- tions to implement secret-redaction for programs written in C/C++. A system that is similar to ours is using a custom compiler to first do static analysis and then decide whether and how the program should be analyzed dynamically [42]. The LLVM compiler suite has also been a popular target for compiler- based approaches. There is a GitHub project for an LLVM-based taint tracking implementation where tracking code is injected into programs, similar to our approach. However, the project was last updated January 2013 and provides no documentation. Compiler-assisted taint tracking has also been applied to binaries. In [43], architecture-dependent binary code is retargeted to LLVM’s intermediate representation. Afterwards, using a data-flow model for LLVM’s IR, the taint tracking can be implemented independent of the original ISA for which the program was written. An LLVM extension has been created to assist the collection of provenance information [44]. While most provenance systems reside in privileged space and only collect data from the outside of the process, instrumenting apps to collect this data provides an intra-process view on prove- nance information. Finally, [45] extended LLVM to check apps and framework code running on the Tizen operating system for the presence of inlined security checks.
While most of the above approaches require the developer to explicitly use the respective modified compilers, Android’s on-device compiler provides the great opportunity to use a custom compiler completely independent of the program’s developer. With this approach, it is now possible to apply compiler-assisted sys- tems to Android apps in the wild without requiring their developers to recompile them.

\section{Hashing}

\section{SQL injection}

\section{Randomness}


In fact, as shown by AspectDroid\cite{AspectDroid}, CHEX\cite{chex} and others, this techniques is still valid and allows to hook Android application's byte-code. However, on this OS, this approach also requires re-packaging, thus breaking application updates for users. Therefore, this thesis aims in keeping this possibilities for the user and base its novelty on the new approach provided by ARTist\cite{artist} which instruments application using the Android Runtime.